# --------------------------------
# WIP
# --------------------------------

import time
import numpy as np
from FridgeFunctions.strategies.base import MeasureStrategy

class MFLISigInMeasureAvg(MeasureStrategy):
    """
    For measuring time-averaged signals into the Zurich Instruments MFLI Sig Input.

    This takes data from the MFLI scope. The averaging is done in the MFLI, and the final
    wave data is returned as a numpy array. For the time domain, a futher averaging is done
    to give a single value. For the frequency domain, the data is left as is for spectral
    analysis.
    """
    
    def __init__(self):
        self.sigin = None
        self.scope = None
        self.mode = "time"  # "time" or "freq"
    
    def setup(self, instrument, mode="time", **kwargs):
        
        self.sigin = instrument.sigins[0]  # There is only one sigin on the MFLI (when both are used, it is for a differential measurement)
        self.scope = instrument.scopes[0]  # There is only one scope on the MFLI
        self.mode = mode.lower()  # This should reflect the settings in the LabOne GUI, there is no way to set this remotely

        self.sigin.float(kwargs.get("float", False))
        self.sigin.ac(kwargs.get("ac", False))
        self.sigin.imp50(kwargs.get("imp50", False))
        self.sigin.diff(kwargs.get("diff", False))
        self.sigin.scaling(kwargs.get("scaling", 1.0))
        if "range" in kwargs:
            self.sigin.range(kwargs["range"])
        else:
            self.sigin.autorange(True)

        # Setup the scope
        self.scope.channels[kwargs.get("scope_channel_idx", 0)].inputselect("sigin0")
        self.scope.time(kwargs.get("scope_sampling_rate", 1))  # time, confusingly, defines the sampling rate. See MFLI docs for details
        self.scope.length(kwargs.get("scope_length", 2**14))
        self.scope.wave.subscribe()

    def measure(self, session, poll_time=None, n_shots=None):
        """ Note: averaging should be enabled in the MFLI GUI, this is not done here. """

        # Only one of poll_time or n_shots should be specified
        if poll_time is not None and n_shots is not None:
            raise ValueError("Specify either poll_time or n_shots, not both.")
        elif poll_time is None and n_shots is None:
            raise ValueError("Specify either poll_time or n_shots.")
        
        # Calculate poll_time if n_shots is provided
        if poll_time is not None:
            pass
        elif n_shots is not None and n_shots == 1:
            self.scope.single(True)  # Single shot mode
            poll_time = 1.5 * self.scope.length() / self.scope.time()
        else:
            poll_time = (n_shots+1) * self.scope.length() / self.scope.time()  # Take one extra shot to ensure no data gets cut off

        # Ensure sigin is ranged correctly
        self.scope.enable(True)
        time.sleep(0.1)
        self.sigin.autorange(True)
        self.scope.enable(False)

        # Then record the data and allow the MFLI to do the averaging
        self.scope.enable(True)
        time.sleep(poll_time)  # Collect data
        self.scope.enable(False)
        time.sleep(0.1)

        # Collect final wave data *** CHECK FORMAT OF WAVE DATA ***
        try:
            wave_data = self.scope.wave[-1]["wave"] * self.scope.wave[-1]["channelscaling"][0]  # Check format of wave data
        except Exception:
            logging.error("Error retrieving wave data from MFLI scope.")
            return np.nan
        
        # Do further averaging if in time domain mode
        if self.mode == "time":
            avg_sigin = np.mean(wave_data)
            return avg_sigin
        elif self.mode == "freq":
            return wave_data
        
    def reset(self):
        self.scope.wave.unsubscribe()
